// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: keys.sql

package dbo

import (
	"context"
	"database/sql"
)

const delete = `-- name: Delete :exec
DELETE
FROM value
WHERE namespace = ? AND key = ?
`

type DeleteParams struct {
	Namespace string
	Key       string
}

func (q *Queries) Delete(ctx context.Context, arg DeleteParams) error {
	_, err := q.db.ExecContext(ctx, delete, arg.Namespace, arg.Key)
	return err
}

const deleteExpired = `-- name: DeleteExpired :exec
DELETE
FROM value
WHERE expire_at < unixepoch() * 1000
`

func (q *Queries) DeleteExpired(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpired)
	return err
}

const deleteNamespace = `-- name: DeleteNamespace :exec
DELETE
FROM value
WHERE namespace = ?
`

func (q *Queries) DeleteNamespace(ctx context.Context, namespace string) error {
	_, err := q.db.ExecContext(ctx, deleteNamespace, namespace)
	return err
}

const get = `-- name: Get :one
SELECT value, expire_at, content_type
FROM value
WHERE namespace = ? AND key = ? AND (expire_at IS NULL OR expire_at > unixepoch()*1000)
`

type GetParams struct {
	Namespace string
	Key       string
}

type GetRow struct {
	Value       []byte
	ExpireAt    sql.NullInt64
	ContentType string
}

func (q *Queries) Get(ctx context.Context, arg GetParams) (GetRow, error) {
	row := q.db.QueryRowContext(ctx, get, arg.Namespace, arg.Key)
	var i GetRow
	err := row.Scan(&i.Value, &i.ExpireAt, &i.ContentType)
	return i, err
}

const listNext = `-- name: ListNext :many
SELECT id, "key", namespace, expire_at
FROM value_key
WHERE namespace = ?
  AND id > ?
  AND (expire_at IS NULL OR expire_at > unixepoch() * 1000)
ORDER BY id LIMIT ?
`

type ListNextParams struct {
	Namespace string
	ID        int64
	Limit     int64
}

func (q *Queries) ListNext(ctx context.Context, arg ListNextParams) ([]ValueKey, error) {
	rows, err := q.db.QueryContext(ctx, listNext, arg.Namespace, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ValueKey
	for rows.Next() {
		var i ValueKey
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.Namespace,
			&i.ExpireAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStart = `-- name: ListStart :many

SELECT id, "key", namespace, expire_at
FROM value_key
WHERE namespace = ?
  AND (expire_at IS NULL OR expire_at > unixepoch() * 1000)
ORDER BY id LIMIT ?
`

type ListStartParams struct {
	Namespace string
	Limit     int64
}

// TODO: unixepoch to unixepoch('subsec') once modernc/sqlite will switch to 3.42
func (q *Queries) ListStart(ctx context.Context, arg ListStartParams) ([]ValueKey, error) {
	rows, err := q.db.QueryContext(ctx, listStart, arg.Namespace, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ValueKey
	for rows.Next() {
		var i ValueKey
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.Namespace,
			&i.ExpireAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const put = `-- name: Put :exec
INSERT INTO value (namespace, key, value, expire_at, content_type)
VALUES (?, ?, ?, ?, ?) ON CONFLICT (namespace, key) DO
UPDATE SET expire_at = excluded.expire_at, value = excluded.value, content_type = excluded.content_type
`

type PutParams struct {
	Namespace   string
	Key         string
	Value       []byte
	ExpireAt    sql.NullInt64
	ContentType string
}

func (q *Queries) Put(ctx context.Context, arg PutParams) error {
	_, err := q.db.ExecContext(ctx, put,
		arg.Namespace,
		arg.Key,
		arg.Value,
		arg.ExpireAt,
		arg.ContentType,
	)
	return err
}
